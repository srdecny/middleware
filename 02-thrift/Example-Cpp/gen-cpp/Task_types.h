/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Task_TYPES_H
#define Task_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>




struct FetchState {
  enum type {
    PENDING = 1,
    ITEMS = 2,
    ENDED = 3
  };
};

extern const std::map<int, const char*> _FetchState_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FetchState::type& val);

std::string to_string(const FetchState::type& val);

typedef std::map<std::string, std::set<std::string> >  Report;

class InvalidKeyException;

class ProtocolException;

class ItemA;

class ItemB;

class ItemC;

class ItemD;

class Item;

class SearchState;

class FetchResult;

typedef struct _InvalidKeyException__isset {
  _InvalidKeyException__isset() : invalidKey(false), expectedKey(false) {}
  bool invalidKey :1;
  bool expectedKey :1;
} _InvalidKeyException__isset;

class InvalidKeyException : public ::apache::thrift::TException {
 public:

  InvalidKeyException(const InvalidKeyException&);
  InvalidKeyException& operator=(const InvalidKeyException&);
  InvalidKeyException() : invalidKey(0), expectedKey(0) {
  }

  virtual ~InvalidKeyException() noexcept;
  int32_t invalidKey;
  int32_t expectedKey;

  _InvalidKeyException__isset __isset;

  void __set_invalidKey(const int32_t val);

  void __set_expectedKey(const int32_t val);

  bool operator == (const InvalidKeyException & rhs) const
  {
    if (!(invalidKey == rhs.invalidKey))
      return false;
    if (!(expectedKey == rhs.expectedKey))
      return false;
    return true;
  }
  bool operator != (const InvalidKeyException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InvalidKeyException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept;
};

void swap(InvalidKeyException &a, InvalidKeyException &b);

std::ostream& operator<<(std::ostream& out, const InvalidKeyException& obj);

typedef struct _ProtocolException__isset {
  _ProtocolException__isset() : message(false) {}
  bool message :1;
} _ProtocolException__isset;

class ProtocolException : public ::apache::thrift::TException {
 public:

  ProtocolException(const ProtocolException&);
  ProtocolException& operator=(const ProtocolException&);
  ProtocolException() : message() {
  }

  virtual ~ProtocolException() noexcept;
  std::string message;

  _ProtocolException__isset __isset;

  void __set_message(const std::string& val);

  bool operator == (const ProtocolException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const ProtocolException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProtocolException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept;
};

void swap(ProtocolException &a, ProtocolException &b);

std::ostream& operator<<(std::ostream& out, const ProtocolException& obj);


class ItemA : public virtual ::apache::thrift::TBase {
 public:

  ItemA(const ItemA&);
  ItemA& operator=(const ItemA&);
  ItemA() : fieldA(0), fieldC(0) {
  }

  virtual ~ItemA() noexcept;
  int16_t fieldA;
  std::vector<int16_t>  fieldB;
  int32_t fieldC;

  void __set_fieldA(const int16_t val);

  void __set_fieldB(const std::vector<int16_t> & val);

  void __set_fieldC(const int32_t val);

  bool operator == (const ItemA & rhs) const
  {
    if (!(fieldA == rhs.fieldA))
      return false;
    if (!(fieldB == rhs.fieldB))
      return false;
    if (!(fieldC == rhs.fieldC))
      return false;
    return true;
  }
  bool operator != (const ItemA &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemA & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemA &a, ItemA &b);

std::ostream& operator<<(std::ostream& out, const ItemA& obj);

typedef struct _ItemB__isset {
  _ItemB__isset() : fieldA(false), fieldB(false), fieldC(false) {}
  bool fieldA :1;
  bool fieldB :1;
  bool fieldC :1;
} _ItemB__isset;

class ItemB : public virtual ::apache::thrift::TBase {
 public:

  ItemB(const ItemB&);
  ItemB& operator=(const ItemB&);
  ItemB() : fieldA() {
  }

  virtual ~ItemB() noexcept;
  std::string fieldA;
  std::set<std::string>  fieldB;
  std::vector<std::string>  fieldC;

  _ItemB__isset __isset;

  void __set_fieldA(const std::string& val);

  void __set_fieldB(const std::set<std::string> & val);

  void __set_fieldC(const std::vector<std::string> & val);

  bool operator == (const ItemB & rhs) const
  {
    if (!(fieldA == rhs.fieldA))
      return false;
    if (!(fieldB == rhs.fieldB))
      return false;
    if (__isset.fieldC != rhs.__isset.fieldC)
      return false;
    else if (__isset.fieldC && !(fieldC == rhs.fieldC))
      return false;
    return true;
  }
  bool operator != (const ItemB &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemB & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemB &a, ItemB &b);

std::ostream& operator<<(std::ostream& out, const ItemB& obj);

typedef struct _ItemC__isset {
  _ItemC__isset() : fieldA(false) {}
  bool fieldA :1;
} _ItemC__isset;

class ItemC : public virtual ::apache::thrift::TBase {
 public:

  ItemC(const ItemC&);
  ItemC& operator=(const ItemC&);
  ItemC() : fieldA(0) {
  }

  virtual ~ItemC() noexcept;
  bool fieldA;

  _ItemC__isset __isset;

  void __set_fieldA(const bool val);

  bool operator == (const ItemC & rhs) const
  {
    if (!(fieldA == rhs.fieldA))
      return false;
    return true;
  }
  bool operator != (const ItemC &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemC & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemC &a, ItemC &b);

std::ostream& operator<<(std::ostream& out, const ItemC& obj);

typedef struct _ItemD__isset {
  _ItemD__isset() : fieldD(false) {}
  bool fieldD :1;
} _ItemD__isset;

class ItemD : public virtual ::apache::thrift::TBase {
 public:

  ItemD(const ItemD&);
  ItemD& operator=(const ItemD&);
  ItemD() : fieldD(0) {
  }

  virtual ~ItemD() noexcept;
  bool fieldD;

  _ItemD__isset __isset;

  void __set_fieldD(const bool val);

  bool operator == (const ItemD & rhs) const
  {
    if (!(fieldD == rhs.fieldD))
      return false;
    return true;
  }
  bool operator != (const ItemD &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemD & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemD &a, ItemD &b);

std::ostream& operator<<(std::ostream& out, const ItemD& obj);

typedef struct _Item__isset {
  _Item__isset() : itemA(false), itemB(false), itemC(false), itemD(false) {}
  bool itemA :1;
  bool itemB :1;
  bool itemC :1;
  bool itemD :1;
} _Item__isset;

class Item : public virtual ::apache::thrift::TBase {
 public:

  Item(const Item&);
  Item& operator=(const Item&);
  Item() {
  }

  virtual ~Item() noexcept;
  ItemA itemA;
  ItemB itemB;
  ItemC itemC;
  ItemD itemD;

  _Item__isset __isset;

  void __set_itemA(const ItemA& val);

  void __set_itemB(const ItemB& val);

  void __set_itemC(const ItemC& val);

  void __set_itemD(const ItemD& val);

  bool operator == (const Item & rhs) const
  {
    if (__isset.itemA != rhs.__isset.itemA)
      return false;
    else if (__isset.itemA && !(itemA == rhs.itemA))
      return false;
    if (__isset.itemB != rhs.__isset.itemB)
      return false;
    else if (__isset.itemB && !(itemB == rhs.itemB))
      return false;
    if (__isset.itemC != rhs.__isset.itemC)
      return false;
    else if (__isset.itemC && !(itemC == rhs.itemC))
      return false;
    if (__isset.itemD != rhs.__isset.itemD)
      return false;
    else if (__isset.itemD && !(itemD == rhs.itemD))
      return false;
    return true;
  }
  bool operator != (const Item &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Item & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Item &a, Item &b);

std::ostream& operator<<(std::ostream& out, const Item& obj);

typedef struct _SearchState__isset {
  _SearchState__isset() : countEstimate(false), fetchedItems(false), multimode(true) {}
  bool countEstimate :1;
  bool fetchedItems :1;
  bool multimode :1;
} _SearchState__isset;

class SearchState : public virtual ::apache::thrift::TBase {
 public:

  SearchState(const SearchState&);
  SearchState& operator=(const SearchState&);
  SearchState() : countEstimate(0), fetchedItems(0), multimode(false) {
  }

  virtual ~SearchState() noexcept;
  int32_t countEstimate;
  int32_t fetchedItems;
  bool multimode;

  _SearchState__isset __isset;

  void __set_countEstimate(const int32_t val);

  void __set_fetchedItems(const int32_t val);

  void __set_multimode(const bool val);

  bool operator == (const SearchState & rhs) const
  {
    if (!(countEstimate == rhs.countEstimate))
      return false;
    if (!(fetchedItems == rhs.fetchedItems))
      return false;
    if (__isset.multimode != rhs.__isset.multimode)
      return false;
    else if (__isset.multimode && !(multimode == rhs.multimode))
      return false;
    return true;
  }
  bool operator != (const SearchState &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SearchState & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SearchState &a, SearchState &b);

std::ostream& operator<<(std::ostream& out, const SearchState& obj);

typedef struct _FetchResult__isset {
  _FetchResult__isset() : state(false), item(false), nextSearchState(false), items(false) {}
  bool state :1;
  bool item :1;
  bool nextSearchState :1;
  bool items :1;
} _FetchResult__isset;

class FetchResult : public virtual ::apache::thrift::TBase {
 public:

  FetchResult(const FetchResult&);
  FetchResult& operator=(const FetchResult&);
  FetchResult() : state((FetchState::type)0) {
  }

  virtual ~FetchResult() noexcept;
  /**
   * 
   * @see FetchState
   */
  FetchState::type state;
  Item item;
  SearchState nextSearchState;
  std::vector<Item>  items;

  _FetchResult__isset __isset;

  void __set_state(const FetchState::type val);

  void __set_item(const Item& val);

  void __set_nextSearchState(const SearchState& val);

  void __set_items(const std::vector<Item> & val);

  bool operator == (const FetchResult & rhs) const
  {
    if (!(state == rhs.state))
      return false;
    if (__isset.item != rhs.__isset.item)
      return false;
    else if (__isset.item && !(item == rhs.item))
      return false;
    if (!(nextSearchState == rhs.nextSearchState))
      return false;
    if (__isset.items != rhs.__isset.items)
      return false;
    else if (__isset.items && !(items == rhs.items))
      return false;
    return true;
  }
  bool operator != (const FetchResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FetchResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FetchResult &a, FetchResult &b);

std::ostream& operator<<(std::ostream& out, const FetchResult& obj);



#endif
